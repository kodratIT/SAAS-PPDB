#!/usr/bin/env node

/**
 * Environment Setup Script
 * Helps setup .env.local file with prompts
 */

const fs = require('fs')
const path = require('path')
const readline = require('readline')

const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
}

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`)
}

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

function question(query) {
  return new Promise(resolve => {
    rl.question(query, resolve)
  })
}

async function setup() {
  log('\nüîß PPDB SaaS - Environment Setup\n', 'cyan')
  log('This wizard will help you setup your .env.local file.\n', 'blue')
  
  const envPath = path.join(process.cwd(), '.env.local')
  
  // Check if .env.local exists
  if (fs.existsSync(envPath)) {
    log('‚ö†Ô∏è  .env.local already exists!', 'yellow')
    const overwrite = await question('Do you want to overwrite it? (y/N): ')
    if (overwrite.toLowerCase() !== 'y') {
      log('\n‚úã Setup cancelled.\n', 'yellow')
      rl.close()
      return
    }
  }
  
  log('\nüìù Please provide the following information:\n', 'blue')
  log('Get Firebase config from: https://console.firebase.google.com/\n', 'cyan')
  
  const config = {}
  
  // Firebase Client
  log('üî• Firebase Client Configuration (Public)', 'blue')
  config.NEXT_PUBLIC_FIREBASE_API_KEY = await question('  API Key: ')
  config.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN = await question('  Auth Domain: ')
  config.NEXT_PUBLIC_FIREBASE_PROJECT_ID = await question('  Project ID: ')
  config.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET = await question('  Storage Bucket: ')
  config.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID = await question('  Messaging Sender ID: ')
  config.NEXT_PUBLIC_FIREBASE_APP_ID = await question('  App ID: ')
  
  // Firebase Admin
  log('\nüîê Firebase Admin Configuration (Server-side)', 'blue')
  log('Get from: Project Settings > Service Accounts > Generate new private key\n', 'cyan')
  const useAdmin = await question('Do you want to setup Firebase Admin? (Y/n): ')
  
  if (useAdmin.toLowerCase() !== 'n') {
    config.FIREBASE_ADMIN_PROJECT_ID = await question('  Project ID: ')
    config.FIREBASE_ADMIN_CLIENT_EMAIL = await question('  Client Email: ')
    log('  Private Key (paste full key, press Enter twice when done):', 'reset')
    
    let privateKey = ''
    let emptyLines = 0
    
    while (emptyLines < 2) {
      const line = await question('')
      if (line === '') {
        emptyLines++
      } else {
        emptyLines = 0
        privateKey += line + '\\n'
      }
    }
    
    config.FIREBASE_ADMIN_PRIVATE_KEY = `"${privateKey.trim()}"`
  }
  
  // Application
  log('\nüöÄ Application Configuration', 'blue')
  config.NEXT_PUBLIC_APP_URL = await question('  App URL (default: http://localhost:3000): ') || 'http://localhost:3000'
  config.NEXT_PUBLIC_APP_NAME = await question('  App Name (default: PPDB SaaS): ') || 'PPDB SaaS'
  
  // Build .env.local content
  let envContent = '# PPDB SaaS Environment Configuration\n'
  envContent += '# Generated by setup script\n'
  envContent += `# Created at: ${new Date().toISOString()}\n\n`
  
  envContent += '# Node Environment\n'
  envContent += 'NODE_ENV=development\n\n'
  
  envContent += '# Firebase Client (Public)\n'
  envContent += `NEXT_PUBLIC_FIREBASE_API_KEY=${config.NEXT_PUBLIC_FIREBASE_API_KEY}\n`
  envContent += `NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=${config.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN}\n`
  envContent += `NEXT_PUBLIC_FIREBASE_PROJECT_ID=${config.NEXT_PUBLIC_FIREBASE_PROJECT_ID}\n`
  envContent += `NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=${config.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET}\n`
  envContent += `NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=${config.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID}\n`
  envContent += `NEXT_PUBLIC_FIREBASE_APP_ID=${config.NEXT_PUBLIC_FIREBASE_APP_ID}\n\n`
  
  if (config.FIREBASE_ADMIN_PROJECT_ID) {
    envContent += '# Firebase Admin (Server-side only)\n'
    envContent += `FIREBASE_ADMIN_PROJECT_ID=${config.FIREBASE_ADMIN_PROJECT_ID}\n`
    envContent += `FIREBASE_ADMIN_CLIENT_EMAIL=${config.FIREBASE_ADMIN_CLIENT_EMAIL}\n`
    envContent += `FIREBASE_ADMIN_PRIVATE_KEY=${config.FIREBASE_ADMIN_PRIVATE_KEY}\n\n`
  }
  
  envContent += '# Application\n'
  envContent += `NEXT_PUBLIC_APP_URL=${config.NEXT_PUBLIC_APP_URL}\n`
  envContent += `NEXT_PUBLIC_APP_NAME=${config.NEXT_PUBLIC_APP_NAME}\n\n`
  
  envContent += '# Features\n'
  envContent += 'NEXT_PUBLIC_ENABLE_ANALYTICS=false\n'
  envContent += 'NEXT_PUBLIC_ENABLE_ERROR_TRACKING=false\n\n'
  
  envContent += '# Firebase Emulator (set to true when using emulators)\n'
  envContent += 'NEXT_PUBLIC_USE_FIREBASE_EMULATOR=false\n'
  
  // Write file
  fs.writeFileSync(envPath, envContent)
  
  log('\n‚úÖ Successfully created .env.local!', 'green')
  log('\nüìù Next steps:', 'blue')
  log('   1. Review .env.local and verify all values', 'reset')
  log('   2. Run: npm run dev', 'reset')
  log('   3. Test Firebase connection: http://localhost:3000/api/test-firebase\n', 'reset')
  
  rl.close()
}

// Run setup
setup().catch(err => {
  log(`\n‚ùå Error: ${err.message}\n`, 'red')
  rl.close()
  process.exit(1)
})
